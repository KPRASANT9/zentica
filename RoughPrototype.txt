1. Expose demoapp as websocket to handle signalling mechnism
2. Redirect the socket event to corresponding peers to establish SDP and ICE connection
3. Communicate betweeen peers using RTCdatachannel



Flow Diagram:

[Browser A]                            [Signaling Server]                              [Browser B]
    |                                         |                                              |
    |---(1) Access Media Devices------------->|                                              |
    |                                         |                                              |
    |<--(1) Access Media Devices--------------|                                              |
    |                                         |                                              |
    |---(2) Create Offer--------------------->|                                              |
    |                                         |---(3) Forward Offer------------------------>|
    |                                         |                                              |
    |                                         |<-(3) Forward Answer-------------------------|
    |<---(2) Receive Answer-------------------|                                              |
    |                                         |                                              |
    |---(4) Exchange ICE Candidates---------->|                                              |
    |                                         |---(4) Exchange ICE Candidates--------------->|
    |                                         |                                              |
    |<--(5) Establish Peer Connection---------|                                              |
    |                                         |                                              |
    |---(5) Establish Peer Connection-------->|                                              |
    |                                         |                                              |
    |---(6) Streaming Data<------------------>|                                              |
    |                                         |                                              |



Implementation:
Signalling Mechansim:

const signalingChannel = new WebSocket('wss://example.com/path');

signalingChannel.onmessage = message => {
    const data = JSON.parse(message.data);
    switch(data.type) {
        case 'offer':
            handleOffer(data);
            break;
        case 'answer':
            handleAnswer(data);
            break;
        case 'new-ice-candidate':
            handleNewIceCandidateMsg(data);
            break;
    }
};

function sendToSignalingChannel(data) {
    signalingChannel.send(JSON.stringify(data));
}



# Client program:

# creating an offer
peerConnection.createOffer()
    .then(offer => peerConnection.setLocalDescription(offer))
    .then(() => {
        // Send the offer to the remote peer via your signaling channel
        sendToSignalingChannel({
            type: 'offer',
            sdp: peerConnection.localDescription
        });
    })
    .catch(error => console.error("Error creating an offer:", error));


# handling the Answer
function handleAnswer(message) {
    const desc = new RTCSessionDescription(message.sdp);
    peerConnection.setRemoteDescription(desc).catch(error => console.error("Error setting remote description:", error));
}






ICE candidates

# Listen for ICE Candidates
# Add an event listener to the peer connection to handle the icecandidate event. This event is triggered whenever the local ICE agent needs to deliver a message to the other peer through the signaling server.
peerConnection.onicecandidate = event => {
    if (event.candidate) {
        // Send the candidate to the remote peer through your signaling channel
        sendToSignalingChannel({
            type: 'new-ice-candidate',
            candidate: event.candidate
        });
    }
};



# handling incoming ICE candidates 
function handleNewIceCandidateMsg(message) {
    const candidate = new RTCIceCandidate(message.candidate);
    peerConnection.addIceCandidate(candidate)
        .catch(error => console.error("Error adding received ICE candidate:", error));
}

Establish ICE for traversing through NAT/Firewalls.









Notes:


Notes:

RTCPeerConnection: This is the main class used to establish peer-to-peer connections. It handles the creation of offers and answers, the negotiation of media and data channels, and the management of ICE candidates.


RTCPeerConnectionIceEvent

RTCSessionDescription: Represents session descriptions which include offers and answers. This is crucial for the signaling process in establishing a WebRTC connection.

RTCIceCandidate: Represents ICE candidates which are used to handle possible network paths for the peer-to-peer connection.

MediaStream, MediaStreamTrack: Used for handling audio and video streams.

RTCDataChannel: Represents a data channel which allows bidirectional communication of arbitrary data.

```puml
<!-- @startuml -->

class RTCPeerConnection {
    +createOffer()
    +createAnswer()
    +addIceCandidate()
}

class RTCSessionDescription {
}

class RTCIceCandidate {
}

class MediaStream {
}

class MediaStreamTrack {
}

class RTCDataChannel {
}

RTCPeerConnection "1" *-- "many" RTCSessionDescription : creates >
RTCPeerConnection "1" *-- "many" RTCIceCandidate : handles >
RTCPeerConnection "1" *-- "many" MediaStreamTrack : uses >
RTCPeerConnection "1" *-- "many" RTCDataChannel : uses >
MediaStream "1" -- "many" MediaStreamTrack : contains >

<!-- @enduml -->
```



